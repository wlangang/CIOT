
### 本章重点内容---“如何对既有代码中的函数进行重构”。


#### 前面对重构的原则及定义做了详细的介绍，所以我们知道，在重构中，最主要的是对函数进行重构，在本篇中提到了函数重构的9大规则。这9大规则在函数代码重构时非常实用，并且也是非常重要的。函数重构的9种类型：

1. Extract Method ---- 提取函数

2. Inline Method ---- 内联函数

3. Replace Temp with Query ---- 以查询取代临时变量

4. Inline Temp ---- 内联临时变量

5. Introduce Explaining Variable ---- 引入解释性变量

6. Split Temporary Variable ---- 分解临时变量

7. Remove Assignments to Parameters ---- 移除对参的赋值

8. Replace Method with Method Object ---- 以函数对象取代函数

9. Substitute Algorithm ---- 替换算法

#### 一. Extract Method(提取函数) ---- 将大函数按模块拆分成几个小的函数

Extract Method被翻译成中文就是提取函数的意思，这一点在代码重构中用的非常非常的多。在重构时提倡将代码模块进行细分，因为模块越小，可重用度就越大。不要写大函数，如果你的函数过大，那么这意味着你的函数需要重构了。因为函数过大，可维护性，可理解性就会变差。并且当你实现类似功能的时候就容易产生重复代码。写代码时，最忌讳的就是代码重复。这也就是经常所说的DRY（Don`t Repeat Yourself）原则。所以当函数过长时，你需要将其细分，将原函数拆分成几个函数。
 
 
例子：下方代码中有两个常量属性，并且该类提供了一个构造器。该类还提供了一个输出方法，就是第一该类中的属性进行打印说明，其实该类中没有什么功能。

Void printOwing= (double amount){

    printBanner();
    
  // print details
  
    System.out.printIn("name:" + _name);
    
    System.out.printIn("amount:" + _amount);
   

  
}


正确做法：下方代码段就是我们重构后的类。经过重构后printOwing()函数就只有两行代码，这样看其中调用的函数名也是很容易理解其作用的。下方拆分出来的三个函数也是一个独立的模块，因为函数短小，所以易于理解，同时也易于重用。

Void printOwing= (double amount){

     printBanner();
     
     printDetails(amount);       
}

Void printDetails= (double amount){

    System.out.printIn("name:" + _name);
    
    System.out.printIn("amount:" + _amount);
     
}

#### 二. Inline Method（内联函数） ---- 将微不足道的小函数进行整合

Inline Method其实是和Extract Method(提取函数)相对的。当你在重构或者平时编程时，对模块进行了过度的封装，也就是使用Extract Method有点过头了，把过于简单的东西进行了封装，比如一个简单的布尔表达式，而且该表达式只被用过一次。此时就是过度的使用Extract Method的表现了。物极必反，所以我们需要使用Inline Method进行中和，将过度封装的函数在放回去，或者将那些没有必要封装的函数放回去。

例子：下方代码中的getRating方法中就返回了一个简单的表达式。

Int getRating(){

      return (moreThanFiveLateDeliveries())? 2 : 1;
}

Boolean moreThanFiveLateDeliveries(){

      return _numberOfLateDeliveries > 5
}

正确做法：将过度封装的函数在放回去，或者将那些没有必要封装的函数放回去。

Int getRating(){

     return (_numberOfLateDeliveries > 5) ? 2 : 1
}


#### 三.Replace Temp with Query（以查询取代临时变量）---- 将一些临时变量使用函数替代

Replace Temp with Query说白了就是将那些有着复杂表达式赋值并且多次使用的临时变量使用查询函数取代，也就是说该临时变量的值是通过函数的返回值来获取的。这样一来在实现类似功能的函数时，这些复杂的临时变量就可以进行复用，从而减少代码的重复率。

例子：在此函数中有一个basePrice临时常量，该常量有一个较为复杂的赋值表达式。

double basePrice = quantity * itemPrice;

if(basePrice > 1000)

     return basePrice * 0.95;
else

     return basePrice * 0.98;

正确做法：新创建一个函数来返回该表达式的值。这个函数中返回的临时变量可以被多次使用。并且上面我们提到的临时常量或者变量都不存在了，取而代之的是查询方法，对应的查询方法返回的就是之前消除的临时变量或常量的值。

if(basePrice() > 1000)
    
     return basePrice() * 0.95;

else

     return basePrice() * 0.98;
// ...

double basePrice(){

     return quantity * itemPrice;
}
     
#### 四、Inline Temp（内联临时变量） ---- 与上面的Replace Temp with Query相反

当临时变量只被一个简单的表达式赋值，而该临时变量妨碍了其他重构手法。此时我们就不应该使用Replace Temp with Query。之所以有时我们会使用到Inline Temp规则，是因为Replace Temp with Query规则使用过度造成的情况，还是物极必反，使用Replace Temp with Query过度时，就需要使用Inline Temp进行修正，当然Inline Temp的示例与Replace Temp with Query正好相反，在此就不做过多的赘述了。

例子：basePrice 这个临时变量，只被简单表达式赋值一次。

double basePrice = anOrder.basePrice();

return basePrice > 1000;

正确做法：将所有对该变量的引用替换为对它赋值的那个表达式自身。

return anOrder.basePrice() > 1000;



